<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.7.3
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: README</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><h1>Celluloid</h1>

<p><a href="http://travis-ci.org/tarcieri/celluloid"><img src="http://travis-ci.org/tarcieri/celluloid.png" alt="Build Status" /></a></p>

<blockquote><p>"I thought of objects being like biological cells and/or individual
computers on a network, only able to communicate with messages"
<em>--Alan Kay, creator of Smalltalk, on the meaning of "object oriented programming"</em></p></blockquote>

<p>Celluloid provides a simple and natural way to build fault-tolerant concurrent
programs in Ruby. With Celluloid, you can build systems out of concurrent
objects just as easily as you build sequential programs out of regular objects.
Recommended for any developer, including novices, Celluloid should help ease
your worries about building multithreaded Ruby programs.</p>

<p>Under the hood, Celluloid wraps regular objects in threads that talk to each
other using messages. These concurrent objects are called "actors". When a
caller wants another actor to execute a method, it literally sends it a
message object telling it what method to execute. The receiver listens on its
mailbox, gets the request, runs the method, and sends the caller the result.
The receiver processes messages in its inbox one-at-a-time, which means that
you don't need to worry about synchronizing access to an object's instance
variables.</p>

<p>In addition to that, Celluloid also gives you the ability to call methods
<em>asynchronously</em>, so the receiver to do things in the background for you
without the caller having to sit around waiting for the result.</p>

<p>Like Celluloid? <a href="http://groups.google.com/group/celluloid-ruby">Join the Google Group</a></p>

<h2>Supported Platforms</h2>

<p>Celluloid works on Ruby 1.9.2, JRuby 1.6 (in 1.9 mode), and Rubinius 2.0. JRuby
or Rubinius are the preferred platforms as they support true concurrent threads.</p>

<p>To use JRuby in 1.9 mode, you'll need to pass the "--1.9" command line option
to the JRuby executable, or set the "JRUBY_OPTS=--1.9" environment variable.</p>

<p>Celluloid works on Rubinius in either 1.8 or 1.9 mode.</p>

<h2>Basic Usage</h2>

<p>To use Celluloid, define a normal Ruby class that includes Celluloid:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='Sheen constant id'>Sheen</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>

  <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span><span class='lparen token'>(</span><span class='name identifier id'>name</span><span class='rparen token'>)</span>
    <span class='@name ivar id'>@name</span> <span class='assign token'>=</span> <span class='name identifier id'>name</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='set_status identifier id'>set_status</span><span class='lparen token'>(</span><span class='status identifier id'>status</span><span class='rparen token'>)</span>
    <span class='@status ivar id'>@status</span> <span class='assign token'>=</span> <span class='status identifier id'>status</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='report identifier id'>report</span>
    <span class='dstring node'>&quot;#{@name} is #{@status}&quot;</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>Now when you create new instances of this class, they're actually concurrent
objects, each running in their own thread:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span> <span class='assign token'>=</span> <span class='Sheen constant id'>Sheen</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='string val'>&quot;Charlie Sheen&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(Sheen:0x00000100a312d0) @name=&quot;Charlie Sheen&quot;&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span><span class='dot token'>.</span><span class='set_status identifier id'>set_status</span> <span class='string val'>&quot;winning!&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;winning!&quot;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span><span class='dot token'>.</span><span class='report identifier id'>report</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Charlie Sheen is winning!&quot;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span><span class='dot token'>.</span><span class='set_status! fid id'>set_status!</span> <span class='string val'>&quot;asynchronously winning!&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span><span class='dot token'>.</span><span class='report identifier id'>report</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Charlie Sheen is asynchronously winning!&quot;</span>
</pre>

<p>You can call methods on this concurrent object just like you would any other
Ruby object. The Sheen#set_status method works exactly like you'd expect,
returning the last expression evaluated.</p>

<p>However, Celluloid's secret sauce kicks in when you call banged predicate
methods (i.e. methods ending in !). Even though the Sheen class has no
set_status! method, you can still call it. Why is this? Because bang methods
have a special meaning in Celluloid. (Note: this also means you can't define
bang methods on Celluloid classes and expect them to be callable from other
objects)</p>

<p>Adding a bang to the end of a method instructs Celluloid that you would like
for the given method to be called <em>asynchronously</em>. This means that rather
than the caller waiting for a response, the caller sends a message to the
concurrent object that you'd like the given method invoked, and then the
caller proceeds without waiting for a response. The concurrent object
receiving the message will then process the method call in the background.</p>

<p>Adding a bang to a method name is a convention in Ruby used to indicate that
the method is in some way "dangerous", and in Celluloid this is no exception.
You have no guarantees that just because you made an asynchronous call it was
ever actually invoked. Asynchronous calls will never raise an exception, even
if an exception occurs when the receiver is processing it. Worse, unhandled
exceptions will crash the receiver, and making an asynchronous call to a
crashed object will not raise an error.</p>

<p>However, you can still handle errors created by asynchronous calls using
two features of Celluloid called <em>supervisors</em> and <em>linking</em>. See the
corresponding sections below for more information.</p>

<h2>Futures</h2>

<p>Futures allow you to request a computation and get the result later. There are
two types of futures supported by Celluloid: method futures and block futures.
Method futures work by invoking the <em>future</em> method on an actor. This method
is analogous to the typical <em>send</em> method in that it takes a method name,
followed by an arbitrary number of arguments, and a block. Let's invoke the
report method from the charlie object used in the above example using a future:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='future identifier id'>future</span> <span class='assign token'>=</span> <span class='charlie identifier id'>charlie</span><span class='dot token'>.</span><span class='future identifier id'>future</span> <span class='symbol val'>:report</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Future:0x000001009759b8&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='future identifier id'>future</span><span class='dot token'>.</span><span class='value identifier id'>value</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Charlie Sheen is winning!&quot;</span>
</pre>

<p>The call to charlie.future immediately returns a Celluloid::Future object,
regardless of how long it takes to execute the "report" method. To obtain
the result of the call to "report", we call the <em>value</em> method of the
future object. This call will block until the value returned from the method
call is available (i.e. the method has finished executing). If an exception
occured during the method call, the call to future.value will reraise the
same exception.</p>

<p>Futures also allow you to background the computation of any block:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='future identifier id'>future</span> <span class='assign token'>=</span> <span class='Celluloid constant id'>Celluloid</span><span class='colon2 op'>::</span><span class='Future constant id'>Future</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span> <span class='integer val'>2</span> <span class='plus op'>+</span> <span class='integer val'>2</span> <span class='rbrace token'>}</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Future:0x000001008425f0&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='future identifier id'>future</span><span class='dot token'>.</span><span class='value identifier id'>value</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>4</span>
</pre>

<p>One thing to be aware of when using futures: always make sure to obtain the
value of any future you make. Futures create a thread in the background which
will continue to run until the future's value is obtained. Failing to obtain
the value of futures you create will leak threads.</p>

<h2>Supervisors</h2>

<p>You may be familiar with tools like Monit or God which keep an eye on your
applications and restart them when they crash. Celluloid supervisors work in
a similar fashion, except instead of monitoring applications, they monitor
individual actors and restart them when they crash. Crashes occur whenever
an unhandled exception is raised anywhere within an actor.</p>

<p>To supervise an actor, start it with the <em>supervise</em> method. Using the Sheen
class from the example above:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='supervisor identifier id'>supervisor</span> <span class='assign token'>=</span> <span class='Sheen constant id'>Sheen</span><span class='dot token'>.</span><span class='supervise identifier id'>supervise</span> <span class='string val'>&quot;Charlie Sheen&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;</span>
</pre>

<p>This created a new Celluloid::Supervisor actor, and also created a new Sheen
actor, giving its initialize method the argument "Charlie Sheen". The
<em>supervise</em> method has the same method signature as <em>new</em>. However, rather
than returning the newly created actor, <em>supervise</em> returns the supervisor.
To retrieve the actor that the supervisor is currently using, use the
Celluloid::Supervisor#actor method:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='supervisor identifier id'>supervisor</span> <span class='assign token'>=</span> <span class='Sheen constant id'>Sheen</span><span class='dot token'>.</span><span class='supervise identifier id'>supervise</span> <span class='string val'>&quot;Charlie Sheen&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span> <span class='assign token'>=</span> <span class='supervisor identifier id'>supervisor</span><span class='dot token'>.</span><span class='actor identifier id'>actor</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(Sheen:0x00000100a312d0)&gt;</span>
</pre>

<p>Supervisors can also automatically put actors into the actor <em>registry</em> using
the supervise_as method:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='Sheen constant id'>Sheen</span><span class='dot token'>.</span><span class='supervise_as identifier id'>supervise_as</span> <span class='symbol val'>:charlie</span><span class='comma token'>,</span> <span class='string val'>&quot;Charlie Sheen&quot;</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='charlie identifier id'>charlie</span> <span class='assign token'>=</span> <span class='Celluloid constant id'>Celluloid</span><span class='colon2 op'>::</span><span class='Actor constant id'>Actor</span><span class='lbrack token'>[</span><span class='symbol val'>:charlie</span><span class='rbrack token'>]</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(Sheen:0x00000100a312d0)&gt;</span>
</pre>

<p>In this case, the supervisor will ensure that an actor of the Sheen class,
created using the given arguments, is aways available by calling
Celluloid::Actor[:charlie]. The first argument to supervise_as is the name
you'd like the newly created actor to be registered under. The remaining
arguments are passed to initialize just like you called <em>new</em>.</p>

<p>See the "Registry" section below for more information on the actor registry</p>

<h2>Linking</h2>

<p>Whenever any unhandled exceptions occur in any of the methods of an actor,
that actor crashes and dies. Let's start with an example:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='JamesDean constant id'>JamesDean</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>
  <span class='class class kw'>class</span> <span class='CarInMyLaneError constant id'>CarInMyLaneError</span> <span class='lt op'>&lt;</span> <span class='StandardError constant id'>StandardError</span><span class='semicolon token'>;</span> <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='drive_little_bastard identifier id'>drive_little_bastard</span>
    <span class='raise identifier id'>raise</span> <span class='CarInMyLaneError constant id'>CarInMyLaneError</span><span class='comma token'>,</span> <span class='string val'>&quot;that guy's gotta stop. he'll see us&quot;</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>Now, let's have James drive Little Bastard and see what happens:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span> <span class='assign token'>=</span> <span class='JamesDean constant id'>JamesDean</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x1068)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span><span class='dot token'>.</span><span class='drive_little_bastard! fid id'>drive_little_bastard!</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span>
<span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x1068) dead&gt;</span>
</pre>

<p>When we told james asynchronously to drive Little Bastard, it killed him! If
we were Elizabeth Taylor, co-star in James' latest film at the time of his
death, we'd certainly want to know when he died. So how can we do that?</p>

<p>Actors can <em>link</em> to other actors they're interested in and want to receive
crash notifications from. In order to receive these events, we need to use the
trap_exit method to be notified of them. Let's look at how a hypothetical
Elizabeth Taylor object could be notified that James Dean has crashed:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='ElizabethTaylor constant id'>ElizabethTaylor</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>
  <span class='trap_exit identifier id'>trap_exit</span> <span class='symbol val'>:actor_died</span>

  <span class='def def kw'>def</span> <span class='actor_died identifier id'>actor_died</span><span class='lparen token'>(</span><span class='actor identifier id'>actor</span><span class='comma token'>,</span> <span class='reason identifier id'>reason</span><span class='rparen token'>)</span>
    <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;Oh no! #{actor.inspect} has died because of a #{reason.class}&quot;</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>We've now used the trap_exit method to configure a callback which is invoked
whenever any linked actors crashed. Now we need to link Elizabeth to James so
James' crash notifications get sent to her:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span> <span class='assign token'>=</span> <span class='JamesDean constant id'>JamesDean</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x11b8)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='elizabeth identifier id'>elizabeth</span> <span class='assign token'>=</span> <span class='ElizabethTaylor constant id'>ElizabethTaylor</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(ElizabethTaylor:0x11f0)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='elizabeth identifier id'>elizabeth</span><span class='dot token'>.</span><span class='link identifier id'>link</span> <span class='james identifier id'>james</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x11b8)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span><span class='dot token'>.</span><span class='drive_little_bastard! fid id'>drive_little_bastard!</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span>
<span class='Oh constant id'>Oh</span> <span class='no! fid id'>no!</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x11b8) dead&gt; has died because of a JamesDean::CarInMyLaneError</span>
</pre>

<p>Elizabeth called the <em>link</em> method to receive crash events from James. Because
Elizabeth was linked to James, when James crashed, James' exit message was
sent to her. Because Elizabeth was trapping the exit messages she received
using the trap_exit method, the callback she specified was invoked, allowing
her to take action (in this case, printing the error). But what would happen
if she weren't trapping exits? Let's break James apart into two separate
objects, one for James himself and one for Little Bastard, his car:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='PorscheSpider constant id'>PorscheSpider</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>
  <span class='class class kw'>class</span> <span class='CarInMyLaneError constant id'>CarInMyLaneError</span> <span class='lt op'>&lt;</span> <span class='StandardError constant id'>StandardError</span><span class='semicolon token'>;</span> <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='drive_on_route_466 identifier id'>drive_on_route_466</span>
    <span class='raise identifier id'>raise</span> <span class='CarInMyLaneError constant id'>CarInMyLaneError</span><span class='comma token'>,</span> <span class='string val'>&quot;head on collision :(&quot;</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>

<span class='class class kw'>class</span> <span class='JamesDean constant id'>JamesDean</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>

  <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span>
    <span class='@little_bastard ivar id'>@little_bastard</span> <span class='assign token'>=</span> <span class='PorscheSpider constant id'>PorscheSpider</span><span class='dot token'>.</span><span class='new_link identifier id'>new_link</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='drive_little_bastard identifier id'>drive_little_bastard</span>
    <span class='@little_bastard ivar id'>@little_bastard</span><span class='dot token'>.</span><span class='drive_on_route_466 identifier id'>drive_on_route_466</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>If you take a look in JamesDean#initialize, you'll notice that to create an
instance of PorcheSpider, James is calling the new_link method.</p>

<p>This method works similarly to <em>new</em>, except it combines <em>new</em> and <em>link</em>
into a single call.</p>

<p>Now what happens if we repeat the same scenario with Elizabeth Taylor watching
for James Dean's crash?</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span> <span class='assign token'>=</span> <span class='JamesDean constant id'>JamesDean</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x1108) @little_bastard=#&lt;Celluloid::Actor(PorscheSpider:0x10ec)&gt;&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='elizabeth identifier id'>elizabeth</span> <span class='assign token'>=</span> <span class='ElizabethTaylor constant id'>ElizabethTaylor</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(ElizabethTaylor:0x1144)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='elizabeth identifier id'>elizabeth</span><span class='dot token'>.</span><span class='link identifier id'>link</span> <span class='james identifier id'>james</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x1108) @little_bastard=#&lt;Celluloid::Actor(PorscheSpider:0x10ec)&gt;&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span><span class='dot token'>.</span><span class='drive_little_bastard! fid id'>drive_little_bastard!</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span>
<span class='Oh constant id'>Oh</span> <span class='no! fid id'>no!</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x1108) dead&gt; has died because of a PorscheSpider::CarInMyLaneError</span>
</pre>

<p>When Little Bastard crashed, it killed James as well. Little Bastard killed
James, and because Elizabeth was trapping James' exit events, she received the
notification of James' death.</p>

<p>Actors that are linked together propagate their error messages to all other
actors that they're linked to. Unless those actors are trapping exit events,
those actors too will die, like James did in this case. If you have many,
many actors linked together in a large object graph, killing one will kill them
all unless they are trapping exits.</p>

<p>This allows you to factor your problem into several actors. If an error occurs
in any of them, it will kill off all actors used in a particular system. In
general, you'll probably want to have a supervisor start a single actor which
is in charge of a particular part of your system, and have that actor
new_link to other actors which are part of the same system. If any error
occurs in any of these actors, all of them will be killed off and the entire
subsystem will be restarted by the supervisor in a clean state.</p>

<p>If, for any reason, you've linked to an actor and want to sever the link,
there's a corresponding <em>unlink</em> method to remove links between actors.</p>

<h2>Registry</h2>

<p>Celluloid lets you register actors so you can refer to them symbolically.
You can register Actors using Celluloid::Actor[]:</p>

<pre class="code"><span class='rshft op'>&gt;&gt;</span> <span class='james identifier id'>james</span> <span class='assign token'>=</span> <span class='JamesDean constant id'>JamesDean</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='Celluloid constant id'>Celluloid</span><span class='colon2 op'>::</span><span class='Actor constant id'>Actor</span><span class='lbrack token'>[</span><span class='symbol val'>:james</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='james identifier id'>james</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;</span>
<span class='rshft op'>&gt;&gt;</span> <span class='Celluloid constant id'>Celluloid</span><span class='colon2 op'>::</span><span class='Actor constant id'>Actor</span><span class='lbrack token'>[</span><span class='symbol val'>:james</span><span class='rbrack token'>]</span>
 <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;</span>
</pre>

<p>The Celluloid::Actor constant acts as a hash, allowing you to register actors
under the name of your choosing, and access actors by name rather than
reference. This is important because actors may crash. If you're attempting to
reference an actor explicitly by storing it in a variable, you may be holding
onto a reference to a crashed copy of that actor, rather than talking to a
working, freshly-restarted version.</p>

<p>The main use of the registry is for interfacing with actors that are
automatically restarted by supervisors when they crash.</p>

<h2>Signaling</h2>

<p>Signaling is an advanced technique similar to condition variables in typical
multithreaded programming. One method within a concurrent object can suspend
itself waiting for a particular event, allowing other methods to run. Another
method can then signal all methods waiting for a particular event, and even
send them a value in the process:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='SignalingExample constant id'>SignalingExample</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span>
  <span class='attr_reader identifier id'>attr_reader</span> <span class='symbol val'>:signaled</span>

  <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span>
    <span class='@signaled ivar id'>@signaled</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='wait_for_signal identifier id'>wait_for_signal</span>
    <span class='value identifier id'>value</span> <span class='assign token'>=</span> <span class='wait identifier id'>wait</span> <span class='symbol val'>:ponycopter</span>
    <span class='@signaled ivar id'>@signaled</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
    <span class='value identifier id'>value</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='send_signal identifier id'>send_signal</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='rparen token'>)</span>
    <span class='signal identifier id'>signal</span> <span class='symbol val'>:ponycopter</span><span class='comma token'>,</span> <span class='value identifier id'>value</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>The wait_for_signal method in turn calls a method called "wait". Wait suspends
the running method until another method of the same object calls the "signal"
method with the same label.</p>

<p>The send_signal method of this class does just that, signaling "ponycopter"
with the given value. This value is returned from the original wait call.</p>

<h2>Handling I/O</h2>

<p>Celluloid provides a separate class of actors which run alongside I/O
operations. These actors are slower and more heavyweight and should only be
used when writing actors that also handle I/O operations.</p>

<p>To create an IO actor, include Celluloid::IO:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='IOActor constant id'>IOActor</span>
  <span class='include identifier id'>include</span> <span class='Celluloid constant id'>Celluloid</span><span class='colon2 op'>::</span><span class='IO constant id'>IO</span>

  <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span><span class='lparen token'>(</span><span class='sock identifier id'>sock</span><span class='rparen token'>)</span>
    <span class='@sock ivar id'>@sock</span> <span class='assign token'>=</span> <span class='sock identifier id'>sock</span>
  <span class='end end kw'>end</span>

  <span class='def def kw'>def</span> <span class='read identifier id'>read</span>
    <span class='wait_readable identifier id'>wait_readable</span><span class='lparen token'>(</span><span class='@sock ivar id'>@sock</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
      <span class='@sock ivar id'>@sock</span><span class='dot token'>.</span><span class='read_nonblock identifier id'>read_nonblock</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<h2>Logging</h2>

<p>By default, Celluloid will log any errors and backtraces from any crashing
actors to STDOUT. However, if you wish you can use any logger which is
duck typed with the standard Ruby Logger API (i.e. it implements the #error
method). For example, if you're using Celluloid within a Rails
application, you'll probably want to do:</p>

<pre class="code"><span class='Celluloid constant id'>Celluloid</span><span class='dot token'>.</span><span class='logger identifier id'>logger</span> <span class='assign token'>=</span> <span class='Rails constant id'>Rails</span><span class='dot token'>.</span><span class='logger identifier id'>logger</span>
</pre>

<p>The logger class you specify must be thread-safe, although with a logging
API about the worst you have to worry about with thread safety bugs is
out-of-order messages in the log.</p>

<h2>Implementation and Gotchas</h2>

<p>Celluloid is fundamentally a messaging system which uses thread-safe proxies
to manage all inter-object communication in the system. While the goal of
these proxies is to make it simple for you to write concurrent programs by
applying the uniform access principle to thread-safe inter-object messaging,
you can't simply forget they're there.</p>

<p>The thread-safety guarantees Celluloid provides around synchronizing access to
instance variables only work so long as all access to actors go through the
proxy objects. If the real objects that Celluloid is wrapping in an actor
manage to leak out of the system, all hell will break loose.</p>

<p>Here are a few rules you can follow to keep this from happening:</p>

<ol>
<li><p><strong><em>NEVER RETURN SELF</em></strong> (or pass self as an argument to other actors): in
cases where you want to pass an actor around to other actors or threads,
use Celluloid.current_actor. If you grab the latest master of Celluloid
off of Github, you can just use the #current_actor method when you are
inside of an actor itself.</p></li>
<li><p>Don't mutate the state of objects you've sent in calls to other actors:
This means you must think about data in one of two different ways: either
you "fire and forget" the data, leaving it for other actors to do with
what they will, or you must treat it as immutable if you have any plans
of sharing it with other actors. If you're paranoid (and when you're
dealing with concurrency, there's nothing wrong with being paranoid),
you can freeze objects so you can detect subsequent mutations (or rather,
turn attempts at mutation into errors).</p></li>
<li><p>Don't mix Ruby thread primitives and calls to other actors: if you make
a call to another actor with a mutex held, you're doing it wrong. It's
perfectly fine and strongly encouraged to call out to thread safe
libraries from Celluloid actors. However, if you're using libraries that
acquire mutexes and then execute callbacks (e.g. they take a block while
they're holding a mutex) the guarantees that Celluloid provides will
become weak and you may encounter deadlocks.</p></li>
<li><p>Use Fibers at your own risk: Celluloid employs Fibers as an intrinsic part
of how it implements actors. While it's possible for certain uses of Fibers
to cooperatively work alongside how Celluloid behaves, in most cases you'll
be writing a check you can't afford. So please ask yourself: why are you
using Fibers, and why can't it be solved by a block? If you've got a really
good reason and you're feeling lucky, knock yourself out.</p></li>
</ol>


<h2>On Thread Safety in Ruby</h2>

<p>Ruby actually has a pretty good story when it comes to thread safety. The best
strategy for thread safety is to share as little state as possible, and if
you do share state, you should never mutate it. The worry of anyone stepping
into a thread safe world is that you're using a bunch of legacy libraries with
dubious thread safety. Who knows what those crazy library authors were doing?</p>

<p>Relax people. You're using a language where somebody can change what the '+'
operator does to numbers. So why aren't we afraid to add numbers? Who knows
what those crazy library authors may have done! Instead of freaking out, we
can learn some telltale signs of things that will cause thread safety problems
in Ruby programs so we can identify potential problem libraries just from how
their APIs behave.</p>

<p>The #1 thread safety issue to look out for in a Ruby library is if it provides
some sort of singleton access to a particular object through a class method,
e.g MyClass.zomgobject, as opposed to asking you do do MyClass.new. If you
aren't allocating the object, it isn't yours, it's somebody else's, and you
better damn well make sure you can share nice, or you shouldn't play with it
at all.</p>

<p>How do we share nicely? Let's find out by first looking at a thread-unsafe
version of a singleton method:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='Foo constant id'>Foo</span>
  <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='current identifier id'>current</span>
    <span class='@foo ivar id'>@foo</span> <span class='opasgn op'>||=</span> <span class='Foo constant id'>Foo</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>Seems bad. All threads will share access to the same Foo object, and there's
also a secondary bug here which means when the object is first being allocated
and memoized as @foo. The first thread that tries to allocate it may get a
different version than all the other threads because the memo value it set
got clobbered by another thread because it's unsynchronized.</p>

<p>What else can we do? It depends on why the library is memoizing. Perhaps the
Foo object has some kind of setup cost, such as making a network connection,
and we want to keep it around instead of setting it up and tearing it down
every time. If that's the case, the simplest thing we can do to make this
code thread safe is to create a thread-specific memo of the object:</p>

<pre class="code"><span class='class class kw'>class</span> <span class='Foo constant id'>Foo</span>
  <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='current identifier id'>current</span>
    <span class='Thread constant id'>Thread</span><span class='dot token'>.</span><span class='current identifier id'>current</span><span class='lbrack token'>[</span><span class='symbol val'>:foo</span><span class='rbrack token'>]</span> <span class='opasgn op'>||=</span> <span class='Foo constant id'>Foo</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>

<p>Keep in mind that this will require N Foo objects for N threads. If each
object is wrapping a network connection, this might be a concern. That said,
if you see this pattern employed in the singleton methods of a library,
it's most likely thread safe, provided that Foo doesn't do other wonky things.</p>

<h2>Contributing to Celluloid</h2>

<ul>
<li>Fork Celluloid on github</li>
<li>Make your changes and send me a pull request</li>
<li>If I like them I'll merge them and give you commit access to my repository</li>
</ul>


<h2>Copyright</h2>

<p>Copyright (c) 2011 Tony Arcieri. See LICENSE.txt for further details.</p>
</div></div>
    
    <div id="footer">
  Generated on Tue Oct 25 00:09:09 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.3 (ruby-1.8.7).
</div>

  </body>
</html>