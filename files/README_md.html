<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>File: README.md [RDoc Documentation]</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../rdoc-style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>README.md</h1>
        <div class='paths'>
          README.md
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2011-06-21 13:25:50 -0600</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            <h1>Celluloid</h1>
            <blockquote>
            &#8220;I thought of objects being like biological cells and/or individual
            computers on a network, only able to communicate with messages&#8221; <br>
            <i>&#8212;Alan Kay, creator of Smalltalk, on the meaning of &#8220;object
            oriented programming&#8220;</i>
            </blockquote>
            <p>
            <a href="../classes/Celluloid.html">Celluloid</a> is a concurrent object
            framework for Ruby inspired by Erlang and the Actor model. <a
            href="../classes/Celluloid.html">Celluloid</a> gives you thread-backed
            objects that run concurrently, providing the simplicity of Ruby objects for
            the most common use cases, but also the ability to call methods
            <em>asynchronously</em>, allowing the receiver to do things in the
            background while the caller carries on with its business. These concurrent
            objects are called &#8220;actors&#8221;. Actors are somewhere in between
            the kind of object you&#8217;re typically used to working with and a
            network service.
            </p>
            <h2>Supported Platforms</h2>
            <hr></hr><p>
            <a href="../classes/Celluloid.html">Celluloid</a> works on Ruby 1.9.2,
            JRuby 1.6 (in 1.9 mode), and Rubinius 2.0. JRuby or Rubinius are the
            preferred platforms as they support true concurrent threads.
            </p>
            <p>
            To use JRuby in 1.9 mode, you&#8217;ll need to pass the
            &#8220;&#8212;1.9&#8220; command line option to the JRuby executable, or
            set the &#8220;JRUBY_OPTS=&#8212;1.9&#8220; environment variable.
            </p>
            <p>
            <a href="../classes/Celluloid.html">Celluloid</a> works on Rubinius in
            either 1.8 or 1.9 mode.
            </p>
            <h2> Usage </h2>
            <hr></hr><p>
            To use <a href="../classes/Celluloid.html">Celluloid</a>, define a normal
            Ruby class that includes <a
            href="../classes/Celluloid/Actor.html">Celluloid::Actor</a>
            </p>
            <pre>class Sheen&#x000A;  include Celluloid::Actor&#x000A;&#x000A;  def initialize(name)&#x000A;    @name = name&#x000A;  end&#x000A;&#x000A;  def set_status(status)&#x000A;    @status = status&#x000A;  end&#x000A;&#x000A;  def report&#x000A;    &quot;#{@name} is #{@status}&quot;&#x000A;  end&#x000A;end</pre>
            <p>
            If you call Sheen.new, you&#8217;ll wind up with a plain old Ruby object.
            To create a concurrent object instead of a regular one, use Sheen.spawn:
            </p>
            <pre>&gt;&gt; charlie = Sheen.spawn &quot;Charlie Sheen&quot;&#x000A; =&gt; #&lt;Celluloid::Actor(Sheen:0x00000100a312d0) @name=&quot;Charlie Sheen&quot;&gt;&#x000A;&gt;&gt; charlie.set_status &quot;winning!&quot;&#x000A; =&gt; &quot;winning!&quot;&#x000A;&gt;&gt; charlie.report&#x000A; =&gt; &quot;Charlie Sheen is winning!&quot;&#x000A;&gt;&gt; charlie.set_status! &quot;asynchronously winning!&quot;&#x000A; =&gt; nil&#x000A;&gt;&gt; charlie.report&#x000A; =&gt; &quot;Charlie Sheen is asynchronously winning!&quot;</pre>
            <p>
            Calling spawn creates a concurrent object running inside its own thread.
            You can call methods on this concurrent object just like you would any
            other Ruby object. The Sheen#set_status method works exactly like
            you&#8217;d expect, returning the last expression evaluated.
            </p>
            <p>
            However, Celluloid&#8217;s secret sauce kicks in when you call banged
            predicate methods (i.e. methods ending in !). Even though the Sheen class
            has no set_status! method, you can still call it. Why is this? Because bang
            methods have a special meaning in <a
            href="../classes/Celluloid.html">Celluloid</a>. (Note: this also means you
            can&#8217;t define bang methods on <a
            href="../classes/Celluloid.html">Celluloid</a> classes and expect them to
            be callable from other objects)
            </p>
            <p>
            Adding a bang to the end of a method instructs <a
            href="../classes/Celluloid.html">Celluloid</a> that you would like for the
            given method to be called <em>asynchronously</em>. This means that rather
            than the caller waiting for a response, the caller sends a message to the
            concurrent object that you&#8217;d like the given method invoked, and then
            the caller proceeds without waiting for a response. The concurrent object
            receiving the message will then process the method call in the background.
            </p>
            <p>
            Adding a bang to a method name is a convention in Ruby used to indicate
            that the method is in some way &#8220;dangerous&#8221;, and in <a
            href="../classes/Celluloid.html">Celluloid</a> this is no exception. You
            have no guarantees that just because you made an asynchronous call it was
            ever actually invoked. Asynchronous calls will never raise an exception,
            even if an exception occurs when the receiver is processing it. Worse,
            unhandled exceptions will crash the receiver, and making an asynchronous
            call to a crashed object will not raise an error.
            </p>
            <p>
            However, you can still handle errors created by asynchronous calls using
            two features of <a href="../classes/Celluloid.html">Celluloid</a> called
            <em>supervisors</em> and <em>linking</em>.
            </p>
            <h2> Supervisors </h2>
            <hr></hr><p>
            You may be familiar with tools like Monit or God which keep an eye on your
            applications and restart them when they crash. <a
            href="../classes/Celluloid.html">Celluloid</a> supervisors work in a
            similar fashion, except instead of monitoring applications, they monitor
            individual actors and restart them when they crash. Crashes occur whenever
            an unhandled exception is raised anywhere within an actor.
            </p>
            <p>
            To supervise an actor, start it with the <em>supervise</em> method. Using
            the Sheen class from the example above:
            </p>
            <pre>&gt;&gt; supervisor = Sheen.supervise &quot;Charlie Sheen&quot;&#x000A; =&gt; #&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;</pre>
            <p>
            This created a new <a
            href="../classes/Celluloid/Supervisor.html">Celluloid::Supervisor</a>
            actor, and also created a new Sheen actor, giving its initialize method the
            argument &#8220;Charlie Sheen&#8221;. The <em>supervise</em> method has the
            same method signature as <em>spawn</em>. However, rather than returning the
            newly created actor, <em>supervise</em> returns the supervisor. To retrieve
            the actor that the supervisor is currently using, use the
            Celluloid::Supervisor#actor method:
            </p>
            <pre>&gt;&gt; supervisor = Sheen.supervise &quot;Charlie Sheen&quot;&#x000A; =&gt; #&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;&#x000A;&gt;&gt; charlie = supervisor.actor&#x000A; =&gt; #&lt;Celluloid::Actor(Sheen:0x00000100a312d0)&gt;</pre>
            <p>
            Supervisors can also automatically put actors into the actor
            <em>registry</em> using the supervise_as method:
            </p>
            <pre>&gt;&gt; Sheen.supervise_as :charlie, &quot;Charlie Sheen&quot;&#x000A; =&gt; #&lt;Celluloid::Supervisor(Sheen) &quot;Charlie Sheen&quot;&gt;&#x000A;&gt;&gt; charlie = Celluloid::Actor[:charlie]&#x000A; =&gt; #&lt;Celluloid::Actor(Sheen:0x00000100a312d0)&gt;</pre>
            <p>
            In this case, the supervisor will ensure that an actor of the Sheen class,
            created using the given arguments, is aways available by calling
            Celluloid::Actor[:charlie]. The first argument to supervise_as is the name
            you&#8217;d like the newly created actor to be registered under. The
            remaining arguments are passed to initialize just like you called
            <em>new</em> or <em>spawn</em>.
            </p>
            <p>
            See the &#8220;Registry&#8221; section below for more information on the
            actor registry
            </p>
            <h2>
            Linking
            </h2>
            <hr></hr><p>
            Whenever any unhandled exceptions occur in any of the methods of an actor,
            that actor crashes and dies. Let&#8217;s start with an example:
            </p>
            <pre>class JamesDean&#x000A;  include Celluloid::Actor&#x000A;  class CarInMyLaneError &lt; StandardError; end&#x000A;&#x000A;  def drive_little_bastard&#x000A;    raise CarInMyLaneError, &quot;that guy's gotta stop. he'll see us&quot;&#x000A;  end&#x000A;end</pre>
            <p>
            Now, let&#8217;s have James drive Little Bastard and see what happens:
            </p>
            <pre>&gt;&gt; james = JamesDean.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x1068)&gt;&#x000A;&gt;&gt; james.drive_little_bastard!&#x000A; =&gt; nil&#x000A;&gt;&gt; james&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x1068) dead&gt;</pre>
            <p>
            When we told james asynchronously to drive Little Bastard, it killed him!
            If we were Elizabeth Taylor, co-star in James&#8217; latest film at the
            time of his death, we&#8217;d certainly want to know when he died. So how
            can we do that?
            </p>
            <p>
            Actors can <em>link</em> to other actors they&#8217;re interested in and
            want to receive crash notifications from. In order to receive these events,
            we need to use the trap_exit method to be notified of them. Let&#8217;s
            look at how a hypothetical Elizabeth Taylor object could be notified that
            James Dean has crashed:
            </p>
            <pre>class ElizabethTaylor&#x000A;  include Celluloid::Actor&#x000A;  trap_exit :actor_died&#x000A;&#x000A;  def actor_died(actor, reason)&#x000A;    puts &quot;Oh no! #{actor.inspect} has died because of a #{reason.class}&quot;&#x000A;  end&#x000A;end</pre>
            <p>
            We&#8217;ve now used the trap_exit method to configure a callback which is
            invoked whenever any linked actors crashed. Now we need to link Elizabeth
            to James so James&#8217; crash notifications get sent to her:
            </p>
            <pre>&gt;&gt; james = JamesDean.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x11b8)&gt;&#x000A;&gt;&gt; elizabeth = ElizabethTaylor.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(ElizabethTaylor:0x11f0)&gt;&#x000A;&gt;&gt; elizabeth.link james&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x11b8)&gt;&#x000A;&gt;&gt; james.drive_little_bastard!&#x000A; =&gt; nil&#x000A;Oh no! #&lt;Celluloid::Actor(JamesDean:0x11b8) dead&gt; has died because of a JamesDean::CarInMyLaneError</pre>
            <p>
            Elizabeth called the <em>link</em> method to receive crash events from
            James. Because Elizabeth was linked to James, when James crashed,
            James&#8217; exit message was sent to her. Because Elizabeth was trapping
            the exit messages she received using the trap_exit method, the callback she
            specified was invoked, allowing her to take action (in this case, printing
            the error). But what would happen if she weren&#8217;t trapping exits?
            Let&#8217;s break James apart into two separate objects, one for James
            himself and one for Little Bastard, his car:
            </p>
            <pre>class PorscheSpider&#x000A;  include Celluloid::Actor&#x000A;  class CarInMyLaneError &lt; StandardError; end&#x000A;&#x000A;  def drive_on_route_466&#x000A;    raise CarInMyLaneError, &quot;head on collision :(&quot;&#x000A;  end&#x000A;end&#x000A;&#x000A;class JamesDean&#x000A;  include Celluloid::Actor&#x000A;&#x000A;  def initialize&#x000A;    @little_bastard = PorscheSpider.spawn_link&#x000A;  end&#x000A;&#x000A;  def drive_little_bastard&#x000A;    @little_bastard.drive_on_route_466&#x000A;  end&#x000A;end</pre>
            <p>
            If you take a look in JamesDean#initialize, you&#8217;ll notice that to
            create an instance of PorcheSpider, James is calling the spawn_link method.
            </p>
            <p>
            This method works similarly to <em>spawn</em>, except it combines
            <em>spawn</em> and <em>link</em> into a single call.
            </p>
            <p>
            Now what happens if we repeat the same scenario with Elizabeth Taylor
            watching for James Dean&#8217;s crash?
            </p>
            <pre>&gt;&gt; james = JamesDean.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x1108) @little_bastard=#&lt;Celluloid::Actor(PorscheSpider:0x10ec)&gt;&gt;&#x000A;&gt;&gt; elizabeth = ElizabethTaylor.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(ElizabethTaylor:0x1144)&gt;&#x000A;&gt;&gt; elizabeth.link james&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x1108) @little_bastard=#&lt;Celluloid::Actor(PorscheSpider:0x10ec)&gt;&gt;&#x000A;&gt;&gt; james.drive_little_bastard!&#x000A; =&gt; nil&#x000A;Oh no! #&lt;Celluloid::Actor(JamesDean:0x1108) dead&gt; has died because of a PorscheSpider::CarInMyLaneError</pre>
            <p>
            When Little Bastard crashed, it killed James as well. Little Bastard killed
            James, and because Elizabeth was trapping James&#8217; exit events, she
            received the notification of James&#8217; death.
            </p>
            <p>
            Actors that are linked together propagate their error messages to all other
            actors that they&#8217;re linked to. Unless those actors are trapping exit
            events, those actors too will die, like James did in this case. If you have
            many, many actors linked together in a large object graph, killing one will
            kill them all unless they are trapping exits.
            </p>
            <p>
            This allows you to factor your problem into several actors. If an error
            occurs in any of them, it will kill off all actors used in a particular
            system. In general, you&#8217;ll probably want to have a supervisor start a
            single actor which is in charge of a particular part of your system, and
            have that actor spawn_link to other actors which are part of the same
            system. If any error occurs in any of these actors, all of them will be
            killed off and the entire subsystem will be restarted by the supervisor in
            a clean state.
            </p>
            <p>
            If, for any reason, you&#8217;ve linked to an actor and want to sever the
            link, there&#8217;s a corresponding <em>unlink</em> method to remove links
            between actors.
            </p>
            <h2>
            Registry
            </h2>
            <hr></hr><p>
            <a href="../classes/Celluloid.html">Celluloid</a> lets you register actors
            so you can refer to them symbolically. You can register Actors using
            Celluloid::Actor[]:
            </p>
            <pre>&gt;&gt; james = JamesDean.spawn&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;&#x000A;&gt;&gt; Celluloid::Actor[:james] = james&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;&#x000A;&gt;&gt; Celluloid::Actor[:james]&#x000A; =&gt; #&lt;Celluloid::Actor(JamesDean:0x80c27ce0)&gt;</pre>
            <p>
            The <a href="../classes/Celluloid/Actor.html">Celluloid::Actor</a> constant
            acts as a hash, allowing you to register actors under the name of your
            choosing, and access actors by name rather than reference. This is
            important because actors may crash. If you&#8217;re attempting to reference
            an actor explicitly by storing it in a variable, you may be holding onto a
            reference to a crashed copy of that actor, rather than talking to a
            working, freshly-restarted version.
            </p>
            <p>
            The main use of the registry is for interfacing with actors that are
            automatically restarted by supervisors when they crash.
            </p>
            <h2>
            Logging
            </h2>
            <hr></hr><p>
            By default, <a href="../classes/Celluloid.html">Celluloid</a> will log any
            errors and backtraces from any crashing actors to STDOUT. However, if you
            wish you can use any logger which is compatible with the standard Ruby
            Logger API. For example, if you&#8217;re using <a
            href="../classes/Celluloid.html">Celluloid</a> within a Rails application,
            you&#8217;ll probably want to do:
            </p>
            <pre>Celluloid.logger = Rails.logger</pre>
            <h2>
            Contributing to <a href="../classes/Celluloid.html">Celluloid</a>
            </h2>
            <hr></hr><ul>
            <li>Fork <a href="../classes/Celluloid.html">Celluloid</a> on github
            
            </li>
            <li>Make your changes and send me a pull request
            
            </li>
            <li>If I like them I&#8217;ll merge them and give you commit access to my
            repository
            
            </li>
            </ul>
            <h2>
            Copyright
            </h2>
            <hr></hr><p>
            Copyright &#169; 2011 Tony Arcieri. See LICENSE.txt for further details.
            </p>
          </div>
          <div id='section'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
